
import {
  collection,
  addDoc,
  updateDoc,
  doc,
  serverTimestamp,
  type WithFieldValue,
} from 'firebase/firestore';
import { db } from '@/lib/firebase/config';
import type { PurchaseOrder, PurchaseOrderItem } from '@/types';
import { errorEmitter } from '@/firebase/error-emitter';
import { FirestorePermissionError } from '@/firebase/errors';

// Input type excludes fields generated by the server
type PurchaseOrderInput = Omit<PurchaseOrder, 'id' | 'createdAt' | 'completedAt'>;

// Type for the form data coming from the reception dialog
interface ReceptionFormItems {
    productId: string;
    name: string;
    orderedQty: number;
    price: number;
    receivedQty: number;
}
interface ReceptionUpdateData {
    status: 'completed';
    items: ReceptionFormItems[];
}


const purchaseOrdersCollection = collection(db, 'purchaseOrders');

export const addPurchaseOrder = (poData: PurchaseOrderInput) => {
  const dataWithTimestamp: WithFieldValue<PurchaseOrderInput> = {
    ...poData,
    createdAt: serverTimestamp(),
  };

  return addDoc(purchaseOrdersCollection, dataWithTimestamp).catch(async (serverError) => {
    const permissionError = new FirestorePermissionError({
      path: purchaseOrdersCollection.path,
      operation: 'create',
      requestResourceData: dataWithTimestamp,
    });
    errorEmitter.emit('permission-error', permissionError);
    throw serverError;
  });
};

// New function to update after reception
export const updatePurchaseOrder = (id: string, receptionData: ReceptionUpdateData) => {
    const poDoc = doc(db, 'purchaseOrders', id);

    // In a real scenario, you'd recalculate the discount here based on supplier rules
    // and the new total. For now, we're just updating the items and status.
    const newSubtotal = receptionData.items.reduce((sum, item) => sum + item.price * item.receivedQty, 0);

    const dataToUpdate = {
        status: receptionData.status,
        subtotal: newSubtotal,
        total: newSubtotal, // Simplified: not recalculating discount
        items: receptionData.items.map(item => ({ // Store both ordered and received
            productId: item.productId,
            name: item.name,
            price: item.price,
            orderedQty: item.orderedQty,
            receivedQty: item.receivedQty, // This is the new field
        })),
        completedAt: serverTimestamp(),
    };

    return updateDoc(poDoc, dataToUpdate).catch(async (serverError) => {
      const permissionError = new FirestorePermissionError({
        path: poDoc.path,
        operation: 'update',
        requestResourceData: dataToUpdate,
      });
      errorEmitter.emit('permission-error', permissionError);
      throw serverError;
    });
};
