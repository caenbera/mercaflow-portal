import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  serverTimestamp,
  type WithFieldValue,
  getDocs,
  query,
  orderBy,
  where,
  limit,
  getDoc,
} from 'firebase/firestore';
import { db } from '@/lib/firebase/config';
import type { Product, ProductSupplier } from '@/types';
import { errorEmitter } from '@/firebase/error-emitter';
import { FirestorePermissionError } from '@/firebase/errors';

// The input type should not include fields that are auto-generated by Firestore.
type ProductInput = Omit<Product, 'id' | 'createdAt'>;
type ProductUpdateInput = Partial<ProductInput>;

const productsCollection = collection(db, 'products');

export const addProduct = (productData: ProductInput) => {
  // Cast to WithFieldValue<Product> to allow serverTimestamp() for createdAt
  const dataWithTimestamp = {
    ...productData,
    createdAt: serverTimestamp(),
  } as WithFieldValue<Product>;

  return addDoc(productsCollection, dataWithTimestamp).catch(async (serverError) => {
    const permissionError = new FirestorePermissionError({
      path: productsCollection.path,
      operation: 'create',
      requestResourceData: dataWithTimestamp,
    });
    errorEmitter.emit('permission-error', permissionError);
    throw serverError;
  });
};

export const updateProduct = (id: string, productData: ProductUpdateInput) => {
  const productDoc = doc(db, 'products', id);
  const dataToUpdate = { ...productData };
  
  // Firestore cannot store `undefined`, so we remove keys that might be undefined
  Object.keys(dataToUpdate).forEach(key => {
    if ((dataToUpdate as any)[key] === undefined) {
      delete (dataToUpdate as any)[key];
    }
  });

  return updateDoc(productDoc, dataToUpdate).catch(async (serverError) => {
    const permissionError = new FirestorePermissionError({
      path: productDoc.path,
      operation: 'update',
      requestResourceData: dataToUpdate,
    });
    errorEmitter.emit('permission-error', permissionError);
    throw serverError;
  });
};

export const deleteProduct = (id: string) => {
  const productDoc = doc(db, 'products', id);
  return deleteDoc(productDoc).catch(async (serverError) => {
    const permissionError = new FirestorePermissionError({
      path: productDoc.path,
      operation: 'delete',
    });
    errorEmitter.emit('permission-error', permissionError);
    throw serverError;
  });
};

export const getProducts = async (): Promise<Product[]> => {
  const productsCollectionRef = collection(db, "products");
  const q = query(productsCollectionRef, orderBy("name.es", "asc"));
  
  try {
    const querySnapshot = await getDocs(q);
    const products: Product[] = [];
    querySnapshot.forEach((doc) => {
      products.push({ id: doc.id, ...doc.data() } as Product);
    });
    return products;
  } catch (e: any) {
     const permissionError = new FirestorePermissionError({
        path: productsCollectionRef.path,
        operation: 'list',
      });
      errorEmitter.emit('permission-error', permissionError);
      throw e;
  }
};

export const getProductBySku = async (sku: string): Promise<Product | null> => {
  if (!sku) return null;
  const q = query(collection(db, 'products'), where('sku', '==', sku), limit(1));
  try {
    const querySnapshot = await getDocs(q);
    if (querySnapshot.empty) {
      return null;
    }
    const docSnap = querySnapshot.docs[0];
    return { id: docSnap.id, ...docSnap.data() } as Product;
  } catch (e) {
    console.error("Error fetching product by SKU: ", e);
    return null;
  }
};
